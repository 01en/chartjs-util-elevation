<!DOCTYPE html>
<html>

<head>
    <title></title>
    <meta charset="utf-8">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="stylesheet" href="">
    <style>
        #chart {
            max-width: 100%;
            position: relative;
            margin: 0 auto;
            padding-top: 40%;
            max-height: 300px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            -webkit-font-kerning: normal;
            font-kerning: normal;
            font-family: "Helvetica Neue", "Roboto", "ヒラギノ角ゴ ProN", "Hiragino Kaku Gothic ProN", "游ゴシック体", "Yu Gothic", YuGothic, Verdana, Meiryo, sans-serif !important;
        }

        #chart svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .axis .domain {
            stroke: #ccc;
            position: relative;
        }

        .axis .tick line {
            stroke: #ccc;
        }

        .axis .tick text {
            fill: #223F4B;
            font-family: "Helvetica Neue", "Roboto", "ヒラギノ角ゴ ProN", "Hiragino Kaku Gothic ProN", "游ゴシック体", "Yu Gothic", YuGothic, Verdana, Meiryo, sans-serif !important;
            font-size: 0.7rem;
        }

        .chart--tooltip {
            position: absolute;
            width: auto;
            height: auto;
            padding: 10px 15px;
            border-radius: 4px;
            /* color: #fff; */
            background: rgba(255, 255, 255, .95);
            -webkit-box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);
            -moz-box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);
            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);
            visibility: hidden;
            font-size: 12px;
            font-weight: bold;
            max-width: 160px;
        }

        .brush .selection {
            fill: palevioletred;
        }
    </style>
</head>

<body>

    <div id="chart"></div>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src='https://unpkg.com/@turf/turf/turf.min.js'></script>
</body>
<script>
    const route = [
        [138.85400805555557, 35.80678388888889, 913.5],
        [138.85428611111112, 35.80724305555555, 912.8],
        [138.8543738888889, 35.80744305555555, 705.5],
        [138.8544238888889, 35.80759305555556, 905.5],
        [138.8544361111111, 35.807743055555555, 907.5],
    ];

    const route2dist = (route) => {
        let dist = [];
        let odo = 0;
        for (i = 0, len = route.length; i < len; i++) {
            if (i === 0) {
                dist.push({ dist: 0, elev: route[i][2] });
                continue;
            }
            const from = turf.point(route[i - 1]);
            const to = turf.point(route[i]);
            odo += turf.distance(from, to);;
            dist.push({ dist: odo, elev: route[i][2] });
        }
        return dist;
    }


    const distData = route2dist(route);
    console.dir(distData)

    const contents = d3.select('#chart');
    const svg = contents.append("svg");
    // tooltipを追加
    const tooltip = d3.select("body").append("div").attr("class", "chart--tooltip");

    const padding = 30;
    let color = d3.rgb("#85a7cc");
    let x, y, xScale, yScale, width, height, line, path, area, lineArea, linearGradient, dataset, focus, focusLine, focusPoint, overlay, brush, brushX;
    let isAnimate = false;
    let isInit = false;

    const lineChart = {
        initialize: function () {
            //            dataset = data.map(function (d) {
            //                // 日付のデータをパース
            //                return { date: timeparser(d.date), value: d.value };
            //            });
            // レンダリング
            this.rendar();
            // アップデート
            this.update();

            //isInit = true;

            // アニメーション
            //this.animate();
            // リサイズ時の処理
            this.resize();
            // データ変更の処理
            //this.dataChange();
            // tooltipを設定
            this.setTooltip();
            // マウスイベントをバインド
            this.mouseEvent();

        },
        rendar: function () {
            // パス要素を追加
            path = svg.append("path");
            // エリアを追加
            lineArea = svg.append("path");

            // svg要素にg要素を追加しクラスを付与しxに代入
            x = svg.append("g")
                .attr("class", "axis axis-x");

            // svg要素にg要素を追加しクラスを付与しyに代入
            y = svg.append("g")
                .attr("class", "axis axis-y");

            // フォーカス要素のグループを追加
            focus = svg.append("g")
                .attr("class", "focus")
                .style("visibility", "hidden")

            // フォーカス時のY軸を追加
            focusLine = focus.append("line");

            // フォーカス時のポイントを追加
            focusPoint = focus.append("circle")
                .attr("r", 4)
                .attr("fill", "#fff")
                .attr("stroke", color)
                .attr("stroke-width", 2)

            // オーバーレイ要素を追加
            overlay = svg.append("rect");
            brush = svg.append("g");

        },
        update: function () {
            // グラフの幅
            width = contents.node().clientWidth - padding;
            // グラフの高さ
            height = contents.node().clientHeight - padding;

            // X軸Y軸を追加
            this.addScales();
            // ラインを追加
            this.addLine();
            // エリアを追加
            this.addArea();

        },
        resize: function () {
            let self = this;
            window.addEventListener("resize", function () {
                // アップデート
                self.update();
            })
        },
        getLine: function () {
            return d3.line()
                // lineのX軸をセット
                .x(function (d) { return xScale(d.dist); })
                // lineのY軸をセット
                .y(function (d) { return yScale(d.elev); })
                // カーブを設定
                .curve(d3.curveCatmullRom.alpha(0.4));
        },
        getArea: function () {
            return d3.area()
                .x(function (d) { return xScale(d.dist); })
                .y1(yScale(0))
                .y0(yScale(0))
                // カーブを設定
                .curve(d3.curveCatmullRom.alpha(0.4));
        },
        addScales: function () {

            // x軸の目盛りの量
            let xTicks = (window.innerWidth < 768) ? 6 : 12;
            // X軸を時間のスケールに設定する
            xScale = d3.scaleLinear()
                // 最小値と最大値を指定しX軸の領域を設定する
                .domain([
                    // 0を最小値として設定
                    0,
                    // データ内の日付の最大値を取得
                    d3.max(distData, function (d) { return d.dist; })
                ])
                // SVG内でのX軸の位置の開始位置と終了位置を指定しX軸の幅を設定する
                .range([padding, width]);

            // Y軸を値のスケールに設定する
            yScale = d3.scaleLinear()
                // 最小値と最大値を指定しX軸の領域を設定する
                .domain([
                    // 0を最小値として設定
                    0,
                    // データ内のvalueの最大値を取得
                    d3.max(distData, function (d) { return d.elev; })
                ])
                // SVG内でのY軸の位置の開始位置と終了位置を指定しY軸の幅を設定する
                .range([height, padding]);

            // scaleをセットしてX軸を作成
            axisx = d3.axisBottom(xScale)
                // グラフの目盛りの数を設定
                .ticks(xTicks)
                // 目盛りの表示フォーマットを設定
                .tickFormat((d) => {
                    return d === 0 ? '' : d + 'km'
                });

            // scaleをセットしてY軸を作成
            axisy = d3.axisLeft(yScale)
                .tickSizeInner(-width)
                .tickFormat((d) => {
                    return d === 0 ? '' : d + 'm'
                });



            // X軸の位置を指定し軸をセット
            x.attr("transform", "translate(" + 0 + "," + (height) + ")")
                .call(axisx);

            // Y軸の位置を指定し軸をセット
            y.attr("transform", "translate(" + padding + "," + 0 + ")")
                .call(axisy);


        },
        addLine: function () {
            //lineを生成
            line = this.getLine();

            path
                // dataをセット
                .datum(distData)
                // strokeカラーを設定
                .attr("stroke", color)
                .attr("fill", "none")
                // strokeカラーを設定
                .attr("stroke-width", 2)
                // d属性を設定
                .attr("d", line)
        },
        addArea: function () {

            area = this.getArea();

            lineArea
                .datum(distData)
                .attr("d", area)
            //                .style("fill", color)


        },
        setTooltip: function () {
            // オーバーレイ要素を設定
            overlay
                .style("fill", "none")
                .style("pointer-events", "all")
                .attr("class", "overlay")
                .attr("width", width)
                .attr("height", height)

            // フォーカスした際のY軸を設定
            focusLine
                .style("stroke", "#ccc")
                .style("stroke-width", "1px")
                .style("stroke-dasharray", "2")
                .attr("class", "x-hover-line hover-line")
                .attr("y1", padding)
                .attr("y2", height)

            // 選択範囲領域
            brush
                .attr("class", "brush")
                .attr("y1", padding)
                .attr("y2", height)

            brushX = d3.brushX().extent([[padding, 0], [width, height]]);
        },
        mouseEvent: function () {
            brush.call(brushX);
            // overlayイベントだがbrushがイベントを食べるのでこちらで発火
            brush.on("mousemove", this.handleMouseMove)
                .on("mouseout", this.handleMouseOut);


        },
        handleMouseMove: function () {
            const bisectDate = d3.bisector(function (d) { return d.dist; }).left;
            let x0 = xScale.invert(d3.mouse(this)[0]),
                i = bisectDate(distData, x0, 1),
                d0 = distData[i - 1],
                d1 = distData[i],
                d = x0 - d0.dist > d1.dist - x0 ? d1 : d0;

            let tooltipY = (d3.event.pageY - 40);
            let tooltipX = (d3.event.pageX + 20);

            if ((window.innerWidth - 160) < tooltipX) {
                tooltipX = (d3.event.pageX - 200);
            }

            tooltip
                .html("")
                .style("visibility", "visible")
                .style("top", tooltipY + "px")
                .style("left", tooltipX + "px")

            tooltip
                .append("div")
                .attr("class", "tooltip--time")
                .html(d3.format(".2f")(d.dist) + 'km<br>' + d.elev + '<small>m</small>')

            focus
                .style("visibility", "visible")
                .attr("transform", "translate(" + xScale(d.dist) + "," + 0 + ")");

            focusPoint.attr("transform", "translate(" + 0 + "," + yScale(d.elev) + ")")

        },
        handleMouseOut: function (d, i) {
            tooltip.style("visibility", "hidden");
            focus.style("visibility", "hidden");
        },
    };

    lineChart.initialize();
</script>

</html>